{
    parserClass="com.github.zinoviy23.intellijIdris.lang.parser.psi.IdrParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="IdrPsi"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.zinoviy23.intellijIdris.lang.parser.psi"
    psiImplPackage="com.github.zinoviy23.intellijIdris.lang.parser.psi.impl"

    elementTypeHolderClass="com.github.zinoviy23.intellijIdris.lang.parser.psi.IdrTokenTypes"
    elementTypeClass="com.github.zinoviy23.intellijIdris.lang.parser.psi.IdrElementType"
    tokenTypeClass="com.github.zinoviy23.intellijIdris.lang.parser.psi.IdrTokenType"

    extends(".*expression")=expression

    tokens=[
        LINE_COMMENT_START="--"
        LINE_COMMENT_TEXT="LINE_COMMENT_TEXT"
        DOC_COMMENT_START="|||"
        DOC_COMMENT_TEXT="DOC_COMMENT_TEXT"
    ]
}

file ::= (module_statement EOL+)? top_level ((EOL+ top_level) | EOL+ <<eof>> | indent)*

private top_level ::= directive | import_statement | data_declaration | operator_declaration | function_specification | function_match

module_statement ::= KW_MODULE identificator_reference {
    pin = 1
}

import_statement ::= KW_IMPORT identificator_reference {
    pin = 1
}

directive ::= DIRECTIVE_START DIRECTIVE_TYPE DIRECTIVE_CONTENT {
    pin = 1
}

function_specification ::= [function_opts_list indent?] IDENTIFICATOR COLON_SIGN type_specification
{
    pin = 3
}

function_opts_list ::= function_opt (indent? function_opt)*

private function_opt ::= (KW_EXPORT | KW_TOTAL | KW_PARTIAL)

identificator_reference ::= IDENTIFICATOR (IDENTIFICATOR_SEP IDENTIFICATOR)*
{
    pin = 1
}

operator_declaration ::= (KW_INFIX | KW_PREFIX | KW_INFIXL | KW_INFIXR) INTEGER_LITERAL operator_list {
    pin = 1
}

data_declaration ::= KW_DATA IDENTIFICATOR (IDENTIFICATOR)* EQ_SIGN indent? data_declaration_variant (indent? OPT_SEP indent? data_declaration_variant)* {
    pin = 1
}

data_declaration_variant ::= IDENTIFICATOR (simple_expression)*

operator_list ::= OPERATOR (COMMA OPERATOR)*

type_specification ::= constraint_list? expression

constraint_list ::= expression ARROW_SIGN indent?

function_match ::= IDENTIFICATOR (simple_expression)* EQ_SIGN indent? expression [indent? function_where_block] {
    pin=1
}

function_where_block ::= KW_WHERE (indent (function_specification | function_match))*

expression ::= escaped_function_call_expression |
               type_expression |
               operator_expression |
               kw_expr |
               function_call_expression |
               simple_expression |
               lambda_expression
{
    recoverWhile = expression_recover
}

private expression_recover ::= !(EOL+ IDENTIFICATOR)

simple_expression ::= list_literal_expression |
                      paren_expression |
                      id_expression |
                      integer_literal_expression |
                      char_literal_expression |
                      string_literal_expression |
                      placeholder_expression

private kw_expr ::= if_expression |
                    case_expression |
                    let_expression


let_expression ::= KW_LET indent? let_entry (indent let_entry)* KW_IN indent? expression {
    pin = 1
}

let_entry ::= IDENTIFICATOR EQ_SIGN expression {
    pin = 2
}

type_expression ::= expression TYPE_SIGN indent? expression (TYPE_SIGN indent? expression)*

id_expression ::= IDENTIFICATOR

placeholder_expression ::= PLACEHOLDER

integer_literal_expression ::= INTEGER_LITERAL

string_literal_expression ::= STRING_QUOTE STRING_CONTENT? STRING_QUOTE {
    pin = 1
}

char_literal_expression ::= CHAR_QUOTE CHAR_CONTENT CHAR_QUOTE {
    pin = 1
}

paren_expression ::= LPAR EOL* paren_expression_end {
    pin = 1
}

paren_expression_end ::= RPAR |
                         OPERATOR RPAR |
                         IDENTIFICATOR COLON_SIGN expression RPAR |
                         expression RPAR |
                         expression_list RPAR

expression_list ::= expression (COMMA expression)+

if_expression ::= KW_IF indent* expression indent* KW_THEN indent* expression indent* KW_ELSE indent* expression [indent | EOL] {
    pin = 1
}

case_expression ::= KW_CASE expression KW_OF expression expression ARROW_SIGN expression {
    pin = 1
}

list_literal_expression ::= LBRACKET [expression (COMMA expression)*] RBRACKET {
    pin = 1
}

operator_expression ::= expression OPERATOR indent? expression (OPERATOR indent? expression)*

escaped_function_call_expression ::= expression escaped_name_id expression

escaped_name_id ::= ESCAPED_NAME_QUOTE ESCAPED_NAME ESCAPED_NAME_QUOTE {
    pin = 1
}

function_call_expression ::= function_element (simple_expression)*

private function_element ::= id_expression | paren_expression

lambda_expression ::= BACKSLASH IDENTIFICATOR ARROW_SIGN expression {
    pin = 2
}

private indent ::= EOL+ OPEN